{"version":3,"sources":["../node_modules/boardgame.io/dist/esm/core.js","shared/games/lc.js"],"names":["PlayerView","STRIP_SECRETS","G","ctx","playerID","r","undefined","secret","players","SUITS","BETS","RANKS","PLAYER_1","PLAYER_2","isBet","card","includes","rank","toOrdinal","indexOf","suit","scoreSuit","cards","length","partition","bets","true","ranks","false","numBets","sum","map","dealCards","deck","random","Shuffle","flatMap","hand1","hand2","i","push","pop","newCards","Object","fromEntries","hand","played","discarded","deckSize","findCardIndex","currentPlayer","findIndex","canPlayCardToBoard","previousCard","last","canPlayCardToDiscard","canDrawCardFromDeck","_ctx","canDrawCardFromDiscard","turn","game","name","minPlayers","maxPlayers","setup","scores","round","moves","playCardToBoard","move","INVALID_MOVE","splice","events","setStage","client","playCardToDiscard","onBegin","stages","drawCard","drawCardFromDeck","next","player","values","score","player1Score","player2Score","entries","key","value","onRoundEnd","endTurn","drawCardFromDiscard","endIf","winner","playerView","endStage","endPhase","endGame","setPhase","setActivePlayers","disableUndo"],"mappings":"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","file":"static/js/7.48a2c275.chunk.js","sourcesContent":["export { v as ActivePlayers, h as INVALID_MOVE, S as Stage, T as TurnOrder } from './turn-order-7578f7f3.js';\nimport 'immer';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * PlayerView reducers.\r\n */\r\nconst PlayerView = {\r\n    /**\r\n     * STRIP_SECRETS\r\n     *\r\n     * Reducer which removes a key named `secret` and\r\n     * removes all the keys in `players`, except for the one\r\n     * corresponding to the current playerID.\r\n     */\r\n    STRIP_SECRETS: (G, ctx, playerID) => {\r\n        let r = { ...G };\r\n        if (r.secret !== undefined) {\r\n            delete r.secret;\r\n        }\r\n        if (r.players) {\r\n            r.players = {\r\n                [playerID]: r.players[playerID],\r\n            };\r\n        }\r\n        return r;\r\n    },\r\n};\n\nexport { PlayerView };\n","import { INVALID_MOVE, PlayerView } from 'boardgame.io/core';\nimport { last, partition, sum } from '../utils';\n\n/** @typedef {import('boardgame.io/dist/types/src/types').Ctx} Ctx **/\n\n/**\n * @typedef {object} Card\n * @property {string} suit\n * @property {number} rank\n *\n * @typedef {{\n *   [suit: string]: (Card & { turn: number })[],\n * }} Cards\n *\n * @typedef {{\n *   secret: {\n *     deck: Card[],\n *   },\n *   players: {\n *     [player: string]: {\n *       hand: Card[],\n *     },\n *   },\n *   played: {\n *     [player: string]: Cards,\n *   },\n *   discarded: Cards,\n *   deckSize: number,\n * }} GameState\n *\n * @typedef {{\n *   scores: {\n *     [player: string]: number[],\n *   },\n *   round: number;\n * }} GameContext\n *\n * @typedef {GameState & GameContext} G\n */\n\nconst SUITS = ['yellow', 'blue', 'white', 'green', 'red' ];\nconst BETS = [-1, -2, -3];\nconst RANKS = [2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconst NUM_ROUNDS = 3;\nconst HAND_SIZE = 8;\n\nconst PLAYER_1 = '0';\nconst PLAYER_2 = '1';\n\n/**\n * @param {Card} card\n * @returns {boolean}\n */\nexport function isBet(card) {\n  return BETS.includes(card.rank);\n}\n\n/**\n * @param {Card} card\n * @returns {number}\n */\nexport function toOrdinal(card) {\n  return (SUITS.indexOf(card.suit) + 1) * 100 + card.rank;\n}\n\n/**\n * @param {G} G\n * @returns {{ winner: string }?}\n */\nfunction checkGameOver(G) {\n  if (G.round < NUM_ROUNDS) {\n    return undefined;\n  }\n\n  const player1Score = sum(G.scores[PLAYER_1]);\n  const player2Score = sum(G.scores[PLAYER_2]);\n\n  let winner;\n\n  if (player1Score > player2Score) {\n    winner = PLAYER_1;\n  } else if (player2Score > player1Score) {\n    winner = PLAYER_2;\n  } else {\n    winner = 'tied';\n  }\n\n  return { winner };\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @returns {string}\n */\nfunction onRoundEnd(G, ctx) {\n  for (const player of [PLAYER_1, PLAYER_2]) {\n    const played = Object.values(Object.values(G.played[player]));\n    const score = sum(played.map(cards => scoreSuit(cards)));\n    G.scores[player].push(score);\n  }\n\n  const player1Score = sum(G.scores[PLAYER_1]);\n  const player2Score = sum(G.scores[PLAYER_2]);\n\n  let next;\n\n  if (player1Score > player2Score) {\n    next = PLAYER_1;\n  } else if (player2Score > player1Score) {\n    next = PLAYER_2;\n  } else {\n    next = ctx.currentPlayer === PLAYER_1 ? PLAYER_2 : PLAYER_1;\n  }\n\n  G.round++;\n\n  for (const [key, value] of Object.entries(dealCards(ctx))) {\n    G[key] = value;\n  }\n\n  return next;\n}\n\n/**\n * @param {G} G\n * @returns {G}\n */\nfunction onTurnStart(G) {\n  return { ...G, deckSize: G.secret.deck.length };\n}\n\n/**\n * @param {Card[]} cards\n * @returns {number}\n */\nexport function scoreSuit(cards) {\n  if (cards.length === 0) {\n    return 0;\n  }\n\n  const { true: bets, false: ranks } = partition(cards, card => isBet(card));\n\n  const numBets = bets.length;\n  const score = sum(ranks.map(card => card.rank));\n  const bonus = cards.length >= 8 ? 20 : 0;\n\n  return (score - 20) * (numBets + 1) + bonus;\n}\n\n/**\n * @param {Ctx} ctx\n * @returns {GameState}\n */\nfunction dealCards(ctx) {\n  const deck = ctx.random.Shuffle(\n    SUITS.flatMap(suit => [\n      ...RANKS.map(rank => ({ suit, rank })),\n      ...BETS.map(rank => ({ suit, rank })),\n    ])\n  );\n\n  const hand1 = [];\n  const hand2 = [];\n\n  for (let i = 0; i < HAND_SIZE; i++) {\n    hand1.push(deck.pop());\n    hand2.push(deck.pop());\n  }\n\n  const newCards = () => Object.fromEntries(SUITS.map(suit => [suit, []]));\n\n  return {\n    secret: {\n      deck,\n    },\n    players: {\n      [PLAYER_1]: {\n        hand: hand1,\n      },\n      [PLAYER_2]: {\n        hand: hand2,\n      },\n    },\n    played: {\n      [PLAYER_1]: newCards(),\n      [PLAYER_2]: newCards(),\n    },\n    discarded: newCards(),\n    deckSize: deck.length,\n  };\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {number}\n */\nfunction findCardIndex(G, ctx, card) {\n  return G.players[ctx.currentPlayer].hand.findIndex(({ rank, suit }) => rank === card.rank && suit === card.suit);\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {string=}\n */\nexport function canPlayCardToBoard(G, ctx, card) {\n  const i = findCardIndex(G, ctx, card);\n\n  if (i === -1) {\n    return 'card_not_in_player_hand';\n  }\n\n  const previousCard = last(G.played[ctx.currentPlayer][card.suit]);\n\n  if (previousCard != null && !isBet(previousCard) && card.rank < previousCard.rank) {\n    return 'card_out_of_order';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {INVALID_MOVE=}\n */\nfunction playCardToBoard(G, ctx, card) {\n  if (canPlayCardToBoard(G, ctx, card) != null) {\n    return INVALID_MOVE;\n  }\n\n  const i = findCardIndex(G, ctx, card);\n  G.players[ctx.currentPlayer].hand.splice(i, 1);\n  G.played[ctx.currentPlayer][card.suit].push({ ...card, turn: ctx.turn });\n  ctx.events.setStage('drawCard');\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {string=}\n */\nexport function canPlayCardToDiscard(G, ctx, card) {\n  const i = findCardIndex(G, ctx, card);\n\n  if (i === -1) {\n    return 'card_not_in_player_hand';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {INVALID_MOVE=}\n */\nfunction playCardToDiscard(G, ctx, card) {\n  if (canPlayCardToDiscard(G, ctx, card) != null) {\n    return INVALID_MOVE;\n  }\n\n  const i = findCardIndex(G, ctx, card);\n  G.players[ctx.currentPlayer].hand.splice(i, 1);\n  G.discarded[card.suit].push({ ...card, turn: ctx.turn });\n  ctx.events.setStage('drawCard');\n}\n\n/**\n * @param {G} G\n * @param {Ctx} _ctx\n * @returns {string=}\n */\nexport function canDrawCardFromDeck(G, _ctx) {\n  if (G.deckSize === 0) {\n    return 'deck_empty';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @returns {INVALID_MOVE=}\n */\nfunction drawCardFromDeck(G, ctx) {\n  if (canDrawCardFromDeck(G, ctx) != null) {\n    return INVALID_MOVE;\n  }\n\n  const card = G.secret.deck.pop();\n  G.players[ctx.currentPlayer].hand.push(card);\n\n  if (G.secret.deck.length === 0) {\n    const next = onRoundEnd(G, ctx);\n    ctx.events.endTurn({ next });\n  } else {\n    ctx.events.endTurn();\n  }\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {string} suit\n * @returns {string=}\n */\nexport function canDrawCardFromDiscard(G, ctx, suit) {\n  if (!SUITS.includes(suit)) {\n    return 'unknown_discard_pile';\n  }\n\n  const card = last(G.discarded[suit]);\n\n  if (card == null) {\n    return 'cannot_draw_from_empty_discard_pile';\n  }\n\n  if (card.turn === ctx.turn) {\n    return 'cannot_draw_just_discarded_card';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {string} suit\n * @returns {INVALID_MOVE?}\n */\nfunction drawCardFromDiscard(G, ctx, suit) {\n  if (canDrawCardFromDiscard(G, ctx, suit) != null) {\n    return INVALID_MOVE;\n  }\n\n  const card = G.discarded[suit].pop();\n  G.players[ctx.currentPlayer].hand.push(card);\n  ctx.events.endTurn();\n}\n\nconst game = {\n  name: 'soaring-cities',\n\n  minPlayers: 2,\n  maxPlayers: 2,\n\n  /**\n   * @param {Ctx} ctx\n   * @returns {G}\n   */\n  setup: (ctx) => ({\n    scores: {\n      [PLAYER_1]: [],\n      [PLAYER_2]: [],\n    },\n    round: 0,\n    ...dealCards(ctx),\n  }),\n\n  moves: {\n    playCardToBoard: {\n      move: playCardToBoard,\n      client: false,\n    },\n    playCardToDiscard: {\n      move: playCardToDiscard,\n      client: false,\n    },\n  },\n\n  turn: {\n    onBegin: onTurnStart,\n\n    stages: {\n      drawCard: {\n        moves: {\n          drawCardFromDeck: {\n            move: drawCardFromDeck,\n            client: false,\n          },\n          drawCardFromDiscard: {\n            move: drawCardFromDiscard,\n            client: false,\n          },\n        },\n      },\n    },\n  },\n\n  endIf: checkGameOver,\n\n  playerView: PlayerView.STRIP_SECRETS,\n\n  events: {\n    endStage: false,\n    endTurn: false,\n    endPhase: false,\n    endGame: false,\n    setStage: false,\n    setPhase: false,\n    setActivePlayers: false,\n  },\n\n  disableUndo: true,\n};\n\nexport default game;\n"],"sourceRoot":""}