{"version":3,"sources":["../node_modules/boardgame.io/dist/esm/core.js","shared/games/lc.js"],"names":["PlayerView","STRIP_SECRETS","G","ctx","playerID","r","undefined","secret","players","SUITS","BETS","RANKS","PLAYER_1","PLAYER_2","isBet","card","includes","rank","toOrdinal","indexOf","suit","onRoundEnd","player","played","Object","values","score","sum","map","cards","scoreSuit","scores","push","player1Score","player2Score","turnOrder","onRoundStart","deck","random","Shuffle","flatMap","hand1","hand2","i","pop","newCards","fromEntries","hand","discarded","deckSize","length","dealCards","partition","bets","true","ranks","false","numBets","findCardIndex","currentPlayer","findIndex","canPlayCardToBoard","previousCard","last","canPlayCardToDiscard","canDrawCardFromDeck","_ctx","canDrawCardFromDiscard","turn","game","name","minPlayers","maxPlayers","setup","moves","playCardToBoard","move","INVALID_MOVE","splice","events","setStage","client","playCardToDiscard","onBegin","order","TurnOrder","CUSTOM_FROM","stages","drawCard","drawCardFromDeck","endTurn","endPhase","drawCardFromDiscard","phases","range","start","next","NUM_ROUNDS","onEnd","endIf","phase","winner","playerView","endStage","endGame","setPhase","setActivePlayers","disableUndo"],"mappings":"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","file":"static/js/7.cfdc8683.chunk.js","sourcesContent":["export { v as ActivePlayers, h as INVALID_MOVE, S as Stage, T as TurnOrder } from './turn-order-7578f7f3.js';\nimport 'immer';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * PlayerView reducers.\r\n */\r\nconst PlayerView = {\r\n    /**\r\n     * STRIP_SECRETS\r\n     *\r\n     * Reducer which removes a key named `secret` and\r\n     * removes all the keys in `players`, except for the one\r\n     * corresponding to the current playerID.\r\n     */\r\n    STRIP_SECRETS: (G, ctx, playerID) => {\r\n        let r = { ...G };\r\n        if (r.secret !== undefined) {\r\n            delete r.secret;\r\n        }\r\n        if (r.players) {\r\n            r.players = {\r\n                [playerID]: r.players[playerID],\r\n            };\r\n        }\r\n        return r;\r\n    },\r\n};\n\nexport { PlayerView };\n","import { INVALID_MOVE, PlayerView, TurnOrder } from 'boardgame.io/core';\nimport { last, partition, range, sum } from '../utils';\n\n/** @typedef {import('boardgame.io/dist/types/src/types').Ctx} Ctx **/\n\n/**\n * @typedef {object} Card\n * @property {string} suit\n * @property {number} rank\n *\n * @typedef {{\n *   [suit: string]: (Card & { turn: number })[],\n * }} Cards\n *\n * @typedef {{\n *   secret: {\n *     deck: Card[],\n *   },\n *   players: {\n *     [player: string]: {\n *       hand: Card[],\n *     },\n *   },\n *   played: {\n *     [player: string]: Cards,\n *   },\n *   discarded: Cards,\n *   deckSize: number,\n * }} GameState\n *\n * @typedef {{\n *   scores: {\n *     [player: string]: number[],\n *   },\n *   turnOrder: string[],\n * }} GameContext\n *\n * @typedef {GameState & GameContext} G\n */\n\nconst SUITS = ['yellow', 'blue', 'white', 'green', 'red' ];\nconst BETS = [-1, -2, -3];\nconst RANKS = [2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconst NUM_ROUNDS = 3;\nconst HAND_SIZE = 8;\n\nconst PLAYER_1 = '0';\nconst PLAYER_2 = '1';\n\n/**\n * @param {Card} card\n * @returns {boolean}\n */\nexport function isBet(card) {\n  return BETS.includes(card.rank);\n}\n\n/**\n * @param {Card} card\n * @returns {number}\n */\nexport function toOrdinal(card) {\n  return (SUITS.indexOf(card.suit) + 1) * 100 + card.rank;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @returns {{ winner: string }?}\n */\nfunction checkGameOver(G, ctx) {\n  if (ctx.phase != null) {\n    return undefined;\n  }\n\n  const player1Score = sum(G.scores[PLAYER_1]);\n  const player2Score = sum(G.scores[PLAYER_2]);\n\n  let winner;\n\n  if (player1Score > player2Score) {\n    winner = PLAYER_1;\n  } else if (player2Score > player1Score) {\n    winner = PLAYER_2;\n  } else {\n    winner = 'tied';\n  }\n\n  return { winner };\n}\n\n/**\n * @param {G} G\n */\nfunction onRoundEnd(G) {\n  for (const player of [PLAYER_1, PLAYER_2]) {\n    const played = Object.values(Object.values(G.played[player]));\n    const score = sum(played.map(cards => scoreSuit(cards)));\n    G.scores[player].push(score);\n  }\n\n  const player1Score = sum(G.scores[PLAYER_1]);\n  const player2Score = sum(G.scores[PLAYER_2]);\n\n  if (player1Score > player2Score) {\n    G.turnOrder = [PLAYER_1, PLAYER_2];\n  } else if (player2Score > player1Score) {\n    G.turnOrder = [PLAYER_2, PLAYER_1];\n  } else {\n    G.turnOrder = [G.turnOrder[1], G.turnOrder[0]];\n  }\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @returns {G}\n */\nfunction onRoundStart(G, ctx) {\n  return { ...G, ...dealCards(ctx) };\n}\n\n/**\n * @param {G} G\n * @returns {G}\n */\nfunction onTurnStart(G) {\n  return { ...G, deckSize: G.secret.deck.length };\n}\n\n/**\n * @param {Card[]} cards\n * @returns {number}\n */\nexport function scoreSuit(cards) {\n  if (cards.length === 0) {\n    return 0;\n  }\n\n  const { true: bets, false: ranks } = partition(cards, card => isBet(card));\n\n  const numBets = bets.length;\n  const score = sum(ranks.map(card => card.rank));\n  const bonus = cards.length >= 8 ? 20 : 0;\n\n  return (score - 20) * (numBets + 1) + bonus;\n}\n\n/**\n * @param {Ctx} ctx\n * @returns {GameState}\n */\nfunction dealCards(ctx) {\n  const deck = ctx.random.Shuffle(\n    SUITS.flatMap(suit => [\n      ...RANKS.map(rank => ({ suit, rank })),\n      ...BETS.map(rank => ({ suit, rank })),\n    ])\n  );\n\n  const hand1 = [];\n  const hand2 = [];\n\n  for (let i = 0; i < HAND_SIZE; i++) {\n    hand1.push(deck.pop());\n    hand2.push(deck.pop());\n  }\n\n  const newCards = () => Object.fromEntries(SUITS.map(suit => [suit, []]));\n\n  return {\n    secret: {\n      deck,\n    },\n    players: {\n      [PLAYER_1]: {\n        hand: hand1,\n      },\n      [PLAYER_2]: {\n        hand: hand2,\n      },\n    },\n    played: {\n      [PLAYER_1]: newCards(),\n      [PLAYER_2]: newCards(),\n    },\n    discarded: newCards(),\n    deckSize: deck.length,\n  };\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {number}\n */\nfunction findCardIndex(G, ctx, card) {\n  return G.players[ctx.currentPlayer].hand.findIndex(({ rank, suit }) => rank === card.rank && suit === card.suit);\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {string=}\n */\nexport function canPlayCardToBoard(G, ctx, card) {\n  const i = findCardIndex(G, ctx, card);\n\n  if (i === -1) {\n    return 'card_not_in_player_hand';\n  }\n\n  const previousCard = last(G.played[ctx.currentPlayer][card.suit]);\n\n  if (previousCard != null && !isBet(previousCard) && card.rank < previousCard.rank) {\n    return 'card_out_of_order';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {INVALID_MOVE=}\n */\nfunction playCardToBoard(G, ctx, card) {\n  if (canPlayCardToBoard(G, ctx, card) != null) {\n    return INVALID_MOVE;\n  }\n\n  const i = findCardIndex(G, ctx, card);\n  G.players[ctx.currentPlayer].hand.splice(i, 1);\n  G.played[ctx.currentPlayer][card.suit].push({ ...card, turn: ctx.turn });\n  ctx.events.setStage('drawCard');\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {string=}\n */\nexport function canPlayCardToDiscard(G, ctx, card) {\n  const i = findCardIndex(G, ctx, card);\n\n  if (i === -1) {\n    return 'card_not_in_player_hand';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {Card} card\n * @returns {INVALID_MOVE=}\n */\nfunction playCardToDiscard(G, ctx, card) {\n  if (canPlayCardToDiscard(G, ctx, card) != null) {\n    return INVALID_MOVE;\n  }\n\n  const i = findCardIndex(G, ctx, card);\n  G.players[ctx.currentPlayer].hand.splice(i, 1);\n  G.discarded[card.suit].push({ ...card, turn: ctx.turn });\n  ctx.events.setStage('drawCard');\n}\n\n/**\n * @param {G} G\n * @param {Ctx} _ctx\n * @returns {string=}\n */\nexport function canDrawCardFromDeck(G, _ctx) {\n  if (G.deckSize === 0) {\n    return 'deck_empty';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @returns {INVALID_MOVE=}\n */\nfunction drawCardFromDeck(G, ctx) {\n  if (canDrawCardFromDeck(G, ctx) != null) {\n    return INVALID_MOVE;\n  }\n\n  const card = G.secret.deck.pop();\n  G.players[ctx.currentPlayer].hand.push(card);\n  ctx.events.endTurn();\n\n  if (G.secret.deck.length === 0) {\n    ctx.events.endPhase();\n  }\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {string} suit\n * @returns {string=}\n */\nexport function canDrawCardFromDiscard(G, ctx, suit) {\n  if (!SUITS.includes(suit)) {\n    return 'unknown_discard_pile';\n  }\n\n  const card = last(G.discarded[suit]);\n\n  if (card == null) {\n    return 'cannot_draw_from_empty_discard_pile';\n  }\n\n  if (card.turn === ctx.turn) {\n    return 'cannot_draw_just_discarded_card';\n  }\n\n  return undefined;\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {string} suit\n * @returns {INVALID_MOVE?}\n */\nfunction drawCardFromDiscard(G, ctx, suit) {\n  if (canDrawCardFromDiscard(G, ctx, suit) != null) {\n    return INVALID_MOVE;\n  }\n\n  const card = G.discarded[suit].pop();\n  G.players[ctx.currentPlayer].hand.push(card);\n  ctx.events.endTurn();\n}\n\nconst game = {\n  name: 'soaring-cities',\n\n  minPlayers: 2,\n  maxPlayers: 2,\n\n  /**\n   * @returns {GameContext}\n   */\n  setup: () => ({\n    scores: {\n      [PLAYER_1]: [],\n      [PLAYER_2]: [],\n    },\n    turnOrder: [PLAYER_1, PLAYER_2],\n  }),\n\n  moves: {\n    playCardToBoard: {\n      move: playCardToBoard,\n      client: false,\n    },\n    playCardToDiscard: {\n      move: playCardToDiscard,\n      client: false,\n    },\n  },\n\n  turn: {\n    onBegin: onTurnStart,\n\n    order: TurnOrder.CUSTOM_FROM('turnOrder'),\n\n    stages: {\n      drawCard: {\n        moves: {\n          drawCardFromDeck: {\n            move: drawCardFromDeck,\n            client: false,\n          },\n          drawCardFromDiscard: {\n            move: drawCardFromDiscard,\n            client: false,\n          },\n        },\n      },\n    },\n  },\n\n  phases: Object.fromEntries(range(NUM_ROUNDS).map(i => ([\n    `Round ${i + 1}`,\n    {\n      start: i === 0,\n      next: i === NUM_ROUNDS - 1 ? undefined : `Round ${i + 2}`,\n      onBegin: onRoundStart,\n      onEnd: onRoundEnd,\n    },\n  ]))),\n\n  endIf: checkGameOver,\n\n  playerView: PlayerView.STRIP_SECRETS,\n\n  events: {\n    endStage: false,\n    endTurn: false,\n    endPhase: false,\n    endGame: false,\n    setStage: false,\n    setPhase: false,\n    setActivePlayers: false,\n  },\n\n  disableUndo: true,\n};\n\nexport default game;\n"],"sourceRoot":""}