{"version":3,"sources":["../node_modules/boardgame.io/dist/esm/core.js","../node_modules/classnames/index.js","shared/games/sgp.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray.js","frontend/boards/sgp/index.js"],"names":["PlayerView","STRIP_SECRETS","G","ctx","playerID","r","undefined","secret","players","hasOwn","hasOwnProperty","classNames","classes","i","arguments","length","arg","argType","push","Array","isArray","inner","apply","key","call","join","module","exports","default","MIN_PLAYERS","MAX_PLAYERS","ONIGIRI_VARIANTS","FRUITS","FRUIT_VARIANTS","range","map","_","variant","flat","pairs","CATEGORIES","NIGIRIS","egg","salmon","squid","ROLLS","maki","temaki","uramaki","APPETIZERS","tempura","sashimi","misoSoup","tofu","eel","dumpling","onigiri","edamame","SPECIALS","wasabi","tea","soySauce","DESSERTS","matchaIceCream","pudding","fruit","scoreHand","hand","otherHands","numRound","score","sum","card","scoreCard","isFruitPlayed","some","otherHand","name","hasAnyFruit","scored","category","getSetInstances","cards","filter","getNumRolls","count","getNumCategories","distinct","round","numPlayers","setSize","setValue","scoreSet","numMakis","otherNumMakis","allNumMakis","sort","reverse","mostMakis","secondMostMakis","thirdMostMakis","numTemakis","otherNumTemakis","allNumTemakis","mostTemakis","leastTemakis","last","scores","allHands","numCards","uaramakis","numCard","numPlayer","shouldScore","numUramakis","find","item","item1","item2","nextScore","pop","player","leftovers","bestCounts","bestCount","turnPlayed","indexOf","numTofus","numEels","numDumplings","counts","Object","fromEntries","type","variants","uniques","entries","shape","numUniques","numOtherPlayersWithEdamame","Math","min","nextNigiri","slice","otherCard","max","values","numCategories","otherNumCategories","allNumCategories","numPuddings","otherNumPuddings","allNumPuddings","mostPuddings","leastPuddings","Error","setInstances","floor","getHandSize","getDeck","setupData","rolls","deck","desserts","appetizers","appetizer1","appetizer2","appetizer3","specials","special1","special2","random","Shuffle","dessert","concat","appetizer","numDesserts","getNumDesserts","getNumRound","gameover","handSize","turn","dealCards","played","getWinner","arr","arrayWithHoles","iterableToArray","unsupportedIterableToArray","nonIterableRest","first","playerScores","winner","bestScore","minPlayers","maxPlayers","setupDataSchema","required","properties","title","minimum","maximum","enum","validateSetupData","includes","setup","startingPlayer","getRandomInt","moves","pickCard","move","picked","isPickInvalid","INVALID_MOVE","removeAt","client","activePlayers","all","Stage","NULL","moveLimit","endIf","_ctx","every","onEnd","isRoundOver","id","events","endGame","value","newHands","Number","playerView","endStage","endTurn","endPhase","setStage","setPhase","setActivePlayers","disableUndo","HelpText","content","console","error","Card","onClick","disabled","useState","isHelpTextShown","setIsHelpTextShown","toggleShowHelpText","useCallback","event","preventDefault","className","clickable","onContextMenu","toLowerCase","showHelpText","Rules","to","target","role","aria-label","Board","matchData","allPlayerIDs","keys","currentPlayerIndex","otherPlayerIDs","playerNameFor","ScoreRow","PlayedCards","partition","true","false"],"mappings":"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","file":"static/js/4.fd0bb3be.chunk.js","sourcesContent":["export { v as ActivePlayers, h as INVALID_MOVE, S as Stage, T as TurnOrder } from './turn-order-7578f7f3.js';\nimport 'immer';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * PlayerView reducers.\r\n */\r\nconst PlayerView = {\r\n    /**\r\n     * STRIP_SECRETS\r\n     *\r\n     * Reducer which removes a key named `secret` and\r\n     * removes all the keys in `players`, except for the one\r\n     * corresponding to the current playerID.\r\n     */\r\n    STRIP_SECRETS: (G, ctx, playerID) => {\r\n        let r = { ...G };\r\n        if (r.secret !== undefined) {\r\n            delete r.secret;\r\n        }\r\n        if (r.players) {\r\n            r.players = {\r\n                [playerID]: r.players[playerID],\r\n            };\r\n        }\r\n        return r;\r\n    },\r\n};\n\nexport { PlayerView };\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import { PlayerView, INVALID_MOVE, Stage } from 'boardgame.io/core';\nimport { distinct, getRandomInt, last, pairs, range, removeAt, sum } from '../utils.js';\n\n/** @typedef {import('boardgame.io/dist/types/src/types').Ctx} Ctx **/\n/** @typedef {import('boardgame.io/dist/types/packages/core').INVALID_MOVE} INVALID_MOVE **/\n\n/**\n * @typedef {{\n *   name: string,\n *   category: string,\n *   scored?: boolean,\n *   count?: number,\n *   variants?: string[],\n *   round?: number,\n * }} Card\n *\n * @typedef {{\n *   secret: {\n *     deck: Card[],\n *     desserts: Card[],\n *   },\n *   players: {\n *     [player: string]: {\n *       hand: Card[],\n *       picked?: Card,\n *     },\n *   },\n *   played: {\n *     [player: string]: Card[],\n *   },\n * }} GameState\n *\n * @typedef {{\n *   scores: {\n *     [player: string]: number[],\n *   },\n *   startingPlayer: string,\n *   setupData: SetupData,\n * }} GameContext\n *\n * @typedef {GameState & GameContext} G\n *\n * @typedef {{\n *   rolls: string,\n *   appetizer1: string,\n *   appetizer2: string,\n *   appetizer3: string,\n *   special1: string,\n *   special2: string,\n *   dessert: string,\n * }} SetupData\n */\n\nconst MIN_PLAYERS = 2;\nconst MAX_PLAYERS = 8;\nconst NUM_ROUNDS = 3;\n\nconst ONIGIRI_VARIANTS = [\n  'square',\n  'circle',\n  'triangle',\n  'rectangle',\n];\n\nconst FRUITS = [\n  'watermelon',\n  'pineapple',\n  'orange',\n];\n\nconst FRUIT_VARIANTS = [\n  ...range(2).map(_ => FRUITS.map(variant => ([variant, variant]))).flat(),\n  ...range(3).map(_ => pairs(FRUITS)).flat(),\n];\n\nconst CATEGORIES = {\n  dessert: 'Dessert',\n  appetizer: 'Appetizer',\n  roll: 'Rolls',\n  nigiri: 'Nigiri',\n  special: 'Special',\n};\n\nexport const NIGIRIS = {\n  egg: 'Egg',\n  salmon: 'Salmon',\n  squid: 'Squid',\n};\n\nexport const ROLLS = {\n  maki: 'Maki',\n  temaki: 'Temaki',\n  uramaki: 'Uramaki',\n};\n\nexport const APPETIZERS = {\n  tempura: 'Tempura',\n  sashimi: 'Sashimi',\n  misoSoup: 'Miso Soup',\n  tofu: 'Tofu',\n  eel: 'Eel',\n  dumpling: 'Dumpling',\n  onigiri: 'Onigiri',\n  edamame: 'Edamame',\n};\n\nexport const SPECIALS = {\n  wasabi: 'Wasabi',\n  tea: 'Tea',\n  soySauce: 'Soy Sauce',\n};\n\nexport const DESSERTS = {\n  matchaIceCream: 'Matcha Ice Cream',\n  pudding: 'Pudding',\n  fruit: 'Fruit',\n};\n\n/**\n * @param {Card[]} hand\n * @param {Card[][]} otherHands\n * @param {number} numRound\n * @returns {number}\n */\nexport function scoreHand(hand, otherHands, numRound) {\n  let score = sum(hand.map(card => scoreCard(card, hand, otherHands, numRound)));\n\n  const isFruitPlayed = otherHands.some(otherHand => otherHand.some(card => card.name === DESSERTS.fruit));\n  const hasAnyFruit = hand.some(card => card.name === DESSERTS.fruit);\n\n  if (isFruitPlayed && !hasAnyFruit) {\n    score -= 6;\n  }\n\n  return score;\n}\n\n/**\n * @param {Card} card\n * @param {Card[]} hand\n * @param {Card[][]} otherHands\n * @param {number} numRound\n * @returns {number}\n */\nexport function scoreCard(card, hand, otherHands, numRound) {\n  if (card.scored) {\n    return 0;\n  }\n\n  if (card.category === CATEGORIES.dessert && numRound !== NUM_ROUNDS) {\n    return 0;\n  }\n\n  /**\n   * @param {Card[]} cards\n   * @returns {Card[]}\n   */\n  const getSetInstances = cards => cards.filter(({ name }) => name === card.name);\n\n  /**\n   * @param {Card[]} cards\n   * @returns {number}\n   */\n  const getNumRolls = cards => sum(getSetInstances(cards).map(({ count }) => count));\n\n  /**\n   * @param {Card[]} cards\n   * @returns {number}\n   */\n  const getNumCategories = cards => distinct(...cards.filter(card => card.round == null).map(({ category }) => category)).length;\n\n  const numPlayers = otherHands.length + 1;\n\n  let setSize = undefined;\n  let setValue = undefined;\n  let scoreSet = false;\n\n  let score = 0;\n\n  switch (card.name) {\n    case NIGIRIS.egg:\n      score = 1;\n      break;\n\n    case NIGIRIS.salmon:\n      score = 2;\n      break;\n\n    case NIGIRIS.squid:\n      score = 3;\n      break;\n\n    case ROLLS.maki:\n      {\n        const numMakis = getNumRolls(hand);\n        const otherNumMakis = otherHands.map(otherHand => getNumRolls(otherHand));\n        const allNumMakis = distinct(numMakis, ...otherNumMakis).sort().reverse();\n        const mostMakis = allNumMakis[0];\n        const secondMostMakis = allNumMakis[1];\n\n        if (numPlayers <= 5) {\n          if (numMakis === mostMakis) {\n            score = 6;\n          } else if (numMakis === secondMostMakis) {\n            score = 3;\n          } else {\n            score = 0;\n          }\n        } else {\n          const thirdMostMakis = allNumMakis[2];\n\n          if (numMakis === mostMakis) {\n            score = 6;\n          } else if (numMakis === secondMostMakis) {\n            score = 4;\n          } else if (numMakis === thirdMostMakis) {\n            score = 2;\n          } else {\n            score = 0;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case ROLLS.temaki:\n      {\n        const numTemakis = getNumRolls(hand);\n        const otherNumTemakis = otherHands.map(otherHand => getNumRolls(otherHand));\n        const allNumTemakis = distinct(numTemakis, ...otherNumTemakis).sort().reverse();\n        const mostTemakis = allNumTemakis[0];\n        const leastTemakis = last(allNumTemakis);\n\n        if (numTemakis === mostTemakis) {\n          score = 4;\n        }\n\n        if (numPlayers > 2) {\n          if (numTemakis === leastTemakis) {\n            score = -4;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case ROLLS.uramaki:\n      {\n        const scores = [2, 5, 8];\n\n        const allHands = [hand, ...otherHands].map(cards => cards.filter(card => card.round == null));\n        const numCards = allHands[0].length;\n        const uaramakis = range(numPlayers).map(_ => ([]));\n\n        for (let numCard = 0; numCard < numCards; numCard++) {\n          for (let numPlayer = 0; numPlayer < numPlayers; numPlayer++) {\n            const card = allHands[numPlayer][numCard];\n\n            if (card.name === ROLLS.uramaki) {\n              uaramakis[numPlayer].push(card.count);\n            }\n          }\n\n          const shouldScore = [];\n\n          for (let numPlayer = 0; numPlayer < numPlayers; numPlayer++) {\n            const numUramakis = sum(uaramakis[numPlayer]);\n\n            if (numUramakis >= 10) {\n              const scored = shouldScore.find(item => item.numUramakis === numUramakis);\n\n              if (scored == null) {\n                shouldScore.push({ numUramakis, players: [numPlayer] });\n              } else {\n                scored.players.push(numPlayer);\n              }\n            }\n          }\n\n          shouldScore.sort((item1, item2) => item2.numUramakis - item1.numUramakis);\n\n          for (const { players } of shouldScore) {\n            const nextScore = scores.pop() || 0;\n\n            for (const player of players) {\n              if (player === 0) {\n                score += nextScore;\n              }\n\n              uaramakis[player] = [];\n            }\n\n            if (players.length > 1) {\n              scores.pop();\n            }\n          }\n        }\n\n        const leftovers = uaramakis.map((cards, i) => ({ player: i, count: sum(cards) }));\n        const bestCounts = distinct(...leftovers.map(({ count }) => count)).sort();\n\n        while (scores.length > 0 && bestCounts.length > 0) {\n          const nextScore = scores.pop();\n          const bestCount = bestCounts.pop();\n\n          for (const { player, count } of leftovers) {\n            if (count === bestCount && player === 0) {\n              score += nextScore;\n            }\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.tempura:\n      setSize = 2;\n      setValue = 5;\n      break;\n\n    case APPETIZERS.sashimi:\n      setSize = 3;\n      setValue = 10;\n      break;\n\n    case APPETIZERS.misoSoup:\n      {\n        const turnPlayed = hand.filter(card => card.round == null).indexOf(card);\n        const hasOtherMisoSoup = otherHands.some(otherHand => otherHand.filter(card => card.round == null)[turnPlayed].name === APPETIZERS.misoSoup);\n        score = hasOtherMisoSoup ? 0 : 3;\n      }\n      break;\n\n    case APPETIZERS.tofu:\n      {\n        const numTofus = getSetInstances(hand).length;\n\n        if (numTofus === 1) {\n          score = 2;\n        } else if (numTofus === 2) {\n          score = 6;\n        } else if (numTofus >= 3) {\n          score = 0;\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.eel:\n      {\n        const numEels = getSetInstances(hand).length;\n\n        if (numEels === 1) {\n          score = -3;\n        } else if (numEels >= 2) {\n          score = 7;\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.dumpling:\n      {\n        const numDumplings = getSetInstances(hand).length;\n\n        if (numDumplings === 1) {\n          score = 1;\n        } else if (numDumplings === 2) {\n          score = 3;\n        } else if (numDumplings === 3) {\n          score = 6;\n        } else if (numDumplings === 4) {\n          score = 10;\n        } else if (numDumplings >= 5) {\n          score = 15;\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.onigiri:\n      {\n        const counts = Object.fromEntries(ONIGIRI_VARIANTS.map(type => [type, 0]));\n\n        for (const card of getSetInstances(hand)) {\n          counts[card.variants[0]]++;\n        }\n\n        while (true) {\n          const uniques = Object.entries(counts).filter(([_, count]) => count > 0).map(([shape, _]) => shape);\n          const numUniques = uniques.length;\n\n          if (numUniques === 0) {\n            break;\n          } else if (numUniques === 4) {\n            score += 16;\n          } else if (numUniques === 3) {\n            score += 9\n          } else if (numUniques === 2) {\n            score += 4;\n          } else if (numUniques === 1) {\n            score += 1;\n          }\n\n          for (const shape of uniques) {\n            counts[shape]--;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.edamame:\n      {\n        const numOtherPlayersWithEdamame = otherHands.filter(otherHand => getSetInstances(otherHand).length > 0).length;\n\n        score = Math.min(4, numOtherPlayersWithEdamame);\n      }\n      break;\n\n    case SPECIALS.wasabi:\n      {\n        const turnPlayed = hand.indexOf(card);\n        const nextNigiri = hand.slice(turnPlayed).filter(otherCard => !otherCard.scored && otherCard.category === CATEGORIES.nigiri)[0];\n\n        if (nextNigiri == null) {\n          score = 0;\n        } else {\n          score = scoreCard(nextNigiri, hand, otherHands, numRound) * 3;\n        }\n      }\n      break;\n\n    case SPECIALS.tea:\n      {\n        const counts = {};\n\n        for (const card of hand) {\n          counts[card.category] = (counts[card.category] || 0) + 1;\n        }\n\n        score = Math.max(...Object.values(counts));\n      }\n      break;\n\n    case SPECIALS.soySauce:\n      {\n        const numCategories = getNumCategories(hand);\n        const otherNumCategories = otherHands.map(otherHand => getNumCategories(otherHand));\n        const allNumCategories = distinct(numCategories, ...otherNumCategories).sort().reverse();\n        const mostCategories = allNumCategories[0];\n\n        if (numCategories === mostCategories) {\n          score = 4;\n        }\n      }\n      break;\n\n    case DESSERTS.matchaIceCream:\n      setSize = 4;\n      setValue = 12;\n      break;\n\n    case DESSERTS.pudding:\n      {\n        const numPuddings = getSetInstances(hand).length;\n        const otherNumPuddings = otherHands.map(otherHand => getSetInstances(otherHand).length);\n        const allNumPuddings = distinct(numPuddings, ...otherNumPuddings).sort().reverse();\n        const mostPuddings = allNumPuddings[0];\n        const leastPuddings = last(allNumPuddings);\n\n        if (numPuddings === mostPuddings) {\n          score = 6;\n        }\n\n        if (numPlayers > 2) {\n          if (numPuddings === leastPuddings) {\n            score = -6;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case DESSERTS.fruit:\n      {\n        const counts = Object.fromEntries(FRUITS.map(variant => [variant, 0]));\n\n        for (const card of getSetInstances(hand)) {\n          for (const variant of card.variants) {\n            counts[variant]++;\n          }\n        }\n\n        for (const count of Object.values(counts)) {\n          if (count === 0) {\n            score -= 2;\n          } else if (count === 1) {\n            score += 0;\n          } else if (count === 2) {\n            score += 1;\n          } else if (count === 3) {\n            score += 3;\n          } else if (count === 4) {\n            score += 6;\n          } else if (count >= 5) {\n            score += 10;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    default:\n      throw new Error(`Unknown card: ${card.name}`);\n  }\n\n  if (setValue != null && setSize != null) {\n    const setInstances = getSetInstances(hand);\n    score = Math.floor(setInstances.length / setSize) * setValue;\n    scoreSet = true;\n  }\n\n  if (scoreSet) {\n    const setInstances = getSetInstances(hand);\n\n    for (const otherCard of setInstances) {\n      otherCard.scored = true;\n    }\n  } else {\n    card.scored = true;\n  }\n\n  return score;\n}\n\n/**\n * @param {number} numPlayers\n * @returns {number}\n */\nfunction getHandSize(numPlayers) {\n  switch (numPlayers) {\n    case 2:\n    case 3:\n      return 10;\n\n    case 4:\n    case 5:\n      return 9;\n\n    case 6:\n    case 7:\n      return 8;\n\n    case 8:\n      return 7;\n\n    default:\n      throw new Error(`Unknown player count: ${numPlayers}`);\n  }\n}\n\n/**\n * @param {number} numPlayers\n * @param {number} numRound\n * @returns {number}\n */\nfunction getNumDesserts(numPlayers, numRound) {\n  switch (numPlayers) {\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      switch (numRound) {\n        case 1:\n          return 5;\n\n        case 2:\n          return 3;\n\n        case 3:\n          return 2;\n\n        default:\n          throw new Error(`Unknown round number: ${numRound}`);\n      }\n\n    case 6:\n    case 7:\n    case 8:\n      switch (numRound) {\n        case 1:\n          return 7;\n\n        case 2:\n          return 5;\n\n        case 3:\n          return 3;\n\n        default:\n          throw new Error(`Unknown round number: ${numRound}`);\n      }\n\n    default:\n      throw new Error(`Unknown player count: ${numPlayers}`);\n  }\n}\n\n/**\n * @param {G?} G\n * @param {Ctx} ctx\n * @param {SetupData} setupData\n * @returns {{ deck: Card[], desserts: Card[]}}\n */\nfunction getDeck(G, ctx, setupData) {\n  setupData = G?.setupData || setupData;\n\n  let rolls = [];\n\n  switch (setupData.rolls) {\n    case ROLLS.maki:\n      rolls = [\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.maki, count: 1 })),\n        ...range(5).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.maki, count: 2 })),\n        ...range(3).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.maki, count: 3 })),\n      ];\n      break;\n\n    case ROLLS.temaki:\n      rolls = range(12).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.temaki, count: 1 }));\n      break;\n\n    case ROLLS.uramaki:\n      rolls = [\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.uramaki, count: 3 })),\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.uramaki, count: 4 })),\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.uramaki, count: 5 })),\n      ];\n      break;\n\n    default:\n      throw new Error(`Unknown rolls: ${setupData.rolls}`);\n  }\n\n  const appetizers = [setupData.appetizer1, setupData.appetizer2, setupData.appetizer3];\n  const specials = [setupData.special1, setupData.special2];\n\n  let deck;\n\n  if (G?.secret?.deck) {\n    deck = G.secret.deck.filter(card => card.category === CATEGORIES.dessert);\n  } else {\n    deck = [];\n  }\n\n  let desserts;\n\n  if (G?.secret?.desserts) {\n    desserts = [...G.secret.desserts];\n  } else {\n    desserts = ctx.random.Shuffle(\n      range(15).map(i => {\n        const dessert = {\n          category: CATEGORIES.dessert,\n          name: setupData.dessert,\n        };\n\n        if (dessert.name === DESSERTS.fruit) {\n          dessert.variants = FRUIT_VARIANTS[i];\n        }\n\n        return dessert;\n      })\n    );\n  }\n\n  deck = deck.concat([\n    ...range(4).map(_ => ({ category: CATEGORIES.nigiri, name: NIGIRIS.egg })),\n    ...range(5).map(_ => ({ category: CATEGORIES.nigiri, name: NIGIRIS.salmon })),\n    ...range(3).map(_ => ({ category: CATEGORIES.nigiri, name: NIGIRIS.squid })),\n    ...rolls,\n    ...appetizers.map(name => range(8).map(i => {\n        const appetizer = {\n          category: CATEGORIES.appetizer,\n          name,\n        };\n\n        if (appetizer.name === APPETIZERS.onigiri) {\n          appetizer.variants = [ONIGIRI_VARIANTS[i % ONIGIRI_VARIANTS.length]];\n        }\n\n        return appetizer;\n      })).flat(),\n    ...specials.map(name => range(3).map(_ => ({ category: CATEGORIES.special, name }))).flat(),\n  ]);\n\n  const numDesserts = getNumDesserts(ctx.numPlayers, getNumRound(ctx));\n\n  for (let i = 0; i < numDesserts; i++) {\n    deck.push(desserts.pop());\n  }\n\n  return {\n    deck: ctx.random.Shuffle(deck),\n    desserts,\n  };\n}\n\n/**\n * @param {Ctx} ctx\n * @returns {number}\n */\nexport function getNumRound(ctx) {\n  if (ctx.gameover) {\n    return NUM_ROUNDS;\n  }\n\n  const handSize = getHandSize(ctx.numPlayers);\n  const turn = ctx.turn === 0 ? ctx.turn : ctx.turn - 1;\n  return Math.floor(turn / handSize) + 1;\n}\n\n/**\n * @param {G?} G\n * @param {Ctx} ctx\n * @param {SetupData?} setupData\n * @returns {GameState}\n */\nfunction dealCards(G, ctx, setupData=null) {\n  const { deck, desserts } = getDeck(G, ctx, setupData);\n\n  const numRound = getNumRound(ctx);\n\n  const players = Object.fromEntries(range(ctx.numPlayers).map(i => ([\n    i,\n    {\n      hand: range(getHandSize(ctx.numPlayers)).map(_ => {\n        const card = deck.pop();\n\n        if (card == null) {\n          throw new Error(`Not enough cards in deck for player ${i}`);\n        }\n\n        return card;\n      }),\n    },\n  ])));\n\n  const played = G?.played\n    ? Object.fromEntries(Object.entries(G.played).map(([playerID, played]) => [\n        playerID,\n        played.filter(card => card.category === CATEGORIES.dessert).map(card => ({\n          ...card,\n          round: numRound - 1,\n        })),\n      ]))\n    : Object.fromEntries(range(ctx.numPlayers).map(playerID => ([\n        playerID,\n        [],\n      ])));\n\n  return {\n    secret: {\n      deck,\n      desserts,\n    },\n    players,\n    played,\n  };\n}\n\n/**\n * @param {G} G\n * @param {Ctx} _ctx\n * @returns {boolean}\n */\nfunction isRoundOver(G, _ctx) {\n  return Object.values(G.players).every(player => player.hand.length === 0);\n}\n\n/**\n * @param {G} G\n * @param {Ctx} _ctx\n * @returns {boolean}\n */\nfunction isTurnOver(G, _ctx) {\n  return Object.values(G.players).every(player => player.picked != null);\n}\n\n/**\n * @param {G} G\n * @returns {{ winner: string }}\n */\nfunction getWinner(G) {\n  const [first, ...playerScores] = Object.entries(G.scores).map(([playerID, scores]) => ({ playerID, score: sum(scores) }));\n  let winner = first.playerID;\n  let bestScore = first.score;\n\n  const numDesserts = Object.fromEntries(Object.entries(G.played).map(([playerID, played]) => [\n    playerID,\n    played.filter(card => card.category === CATEGORIES.dessert).length,\n  ]));\n\n  for (const { playerID, score } of playerScores) {\n    if (score > bestScore || (score === bestScore && numDesserts[playerID] > numDesserts[winner])) {\n      bestScore = score;\n      winner = playerID;\n    }\n  }\n\n  return { winner };\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n */\nfunction onTurnEnd(G, ctx) {\n  for (const [playerID, player] of Object.entries(G.players)) {\n    G.played[playerID].push(player.picked);\n    G.players[playerID].picked = undefined;\n  }\n\n  if (isRoundOver(G, ctx)) {\n    const numRound = getNumRound(ctx);\n\n    for (const [playerID, played] of Object.entries(G.played)) {\n      const otherHands = Object.entries(G.played).filter(([id, _]) => id !== playerID).map(([_, hand]) => hand);\n\n      const score = scoreHand(played, otherHands, numRound);\n\n      G.scores[playerID].push(score);\n    }\n\n    if (numRound === NUM_ROUNDS) {\n      const winner = getWinner(G);\n      ctx.events.endGame(winner);\n    } else {\n      for (const [key, value] of Object.entries(dealCards(G, ctx))) {\n        G[key] = value;\n      }\n    }\n  } else {\n    const newHands = {};\n\n    for (const [playerID, player] of Object.entries(G.players)) {\n      newHands[(Number(playerID) + 1) % ctx.numPlayers] = player.hand;\n    }\n\n    for (const [playerID, hand] of Object.entries(newHands)) {\n      G.players[playerID] = { hand };\n    }\n  }\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {number?} i\n * @returns {string?}\n */\nfunction isPickInvalid(G, ctx, i) {\n  const player = G.players[ctx.playerID];\n\n  if (i == null) {\n    return 'played_no_card';\n  }\n\n  if (i >= player.hand.length) {\n    return 'played_unknown_card';\n  }\n\n  if (player.picked != null) {\n    return 'played_card_already';\n  }\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {number} i\n * @returns {INVALID_MOVE?}\n */\nfunction pickCard(G, ctx, i) {\n  if (isPickInvalid(G, ctx, i)) {\n    return INVALID_MOVE;\n  }\n\n  const player = G.players[ctx.playerID];\n\n  player.picked = player.hand[i];\n  player.hand = removeAt(player.hand, i);\n}\n\nexport default {\n  name: 'sashimi-express',\n\n  minPlayers: MIN_PLAYERS,\n  maxPlayers: MAX_PLAYERS,\n\n  setupDataSchema: {\n    required: [\n      'numPlayers',\n      'rolls',\n      'appetizer1',\n      'appetizer2',\n      'appetizer3',\n      'special1',\n      'special2',\n      'dessert',\n    ],\n    properties: Object.fromEntries([\n      [\n        'numPlayers',\n        {\n          title: 'Number of players',\n          type: 'integer',\n          minimum: MIN_PLAYERS,\n          maximum: MAX_PLAYERS,\n          default: MIN_PLAYERS,\n        },\n      ],\n      [\n        'rolls',\n        {\n          title: 'Rolls',\n          type: 'string',\n          enum: Object.values(ROLLS),\n          default: Object.values(ROLLS)[0],\n        },\n      ],\n      ...range(3).map(i => ([\n        `appetizer${i + 1}`,\n        {\n          title: `Appetizer ${i + 1}`,\n          type: 'string',\n          enum: Object.values(APPETIZERS),\n          default: Object.values(APPETIZERS)[i],\n        },\n      ])),\n      ...range(2).map(i => ([\n        `special${i + 1}`,\n        {\n          title: `Special ${i + 1}`,\n          type: 'string',\n          enum: Object.values(SPECIALS),\n          default: Object.values(SPECIALS)[i],\n        },\n      ])),\n      [\n        'dessert',\n        {\n          title: 'Dessert',\n          type: 'string',\n          enum: Object.values(DESSERTS),\n          default: Object.values(DESSERTS)[0],\n        },\n      ],\n    ]),\n  },\n\n  /**\n   * @param {SetupData} setupData\n   * @param {number} numPlayers\n   * @returns {string?}\n   */\n  validateSetupData: (setupData, numPlayers) => {\n    const appetizers = [setupData.appetizer1, setupData.appetizer2, setupData.appetizer3];\n    const specials = [setupData.special1, setupData.special2];\n\n    if (distinct(...appetizers).length !== appetizers.length) {\n      return 'All appetizers must be different';\n    }\n\n    if (distinct(...specials).length !== specials.length) {\n      return 'All specials must be different';\n    }\n\n    if (numPlayers === 2 && appetizers.includes(APPETIZERS.edamame)) {\n      return `${APPETIZERS.edamame} can't be used in a two player game`;\n    }\n  },\n\n  /**\n   * @param {Ctx} ctx\n   * @param {SetupData} setupData\n   * @returns {G}\n   */\n  setup: (ctx, setupData) => ({\n    ...dealCards(null, ctx, setupData),\n    scores: Object.fromEntries(range(ctx.numPlayers).map(i => [`${i}`, []])),\n    startingPlayer: `${getRandomInt(ctx.numPlayers + 1)}`,\n    setupData,\n  }),\n\n  moves: {\n    pickCard: {\n      move: pickCard,\n      client: false,\n    },\n  },\n\n  turn: {\n    activePlayers: {\n      all: Stage.NULL,\n      moveLimit: 1,\n    },\n    endIf: isTurnOver,\n    onEnd: onTurnEnd,\n  },\n\n  playerView: PlayerView.STRIP_SECRETS,\n\n  events: {\n    endStage: false,\n    endTurn: false,\n    endPhase: false,\n    endGame: false,\n    setStage: false,\n    setPhase: false,\n    setActivePlayers: false,\n  },\n\n  disableUndo: true,\n};\n","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}","import React, { Fragment, useCallback, useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport classNames from 'classnames';\nimport { NIGIRIS, ROLLS, APPETIZERS, SPECIALS, DESSERTS, getNumRound } from '../../../shared/games/sgp';\nimport { partition, range, sum } from '../../../shared/utils';\nimport './index.scss';\n\n/** @typedef {import('boardgame.io/dist/types/src/types').Ctx} Ctx **/\n/** @typedef {import('boardgame.io/dist/types/src/types').LobbyAPI.Match} Match **/\n/** @typedef {import('../../../shared/games/sgp').G} G */\n/** @typedef {import('../../../shared/games/sgp').Card} Card */\n\n/**\n * @param {object} props\n * @param {Ctx} props.ctx\n * @param {Card} props.card\n */\nfunction HelpText({ ctx, card }) {\n  let content;\n\n  switch (card.name) {\n    case NIGIRIS.egg:\n      content = <span>1 point</span>;\n      break;\n\n    case NIGIRIS.salmon:\n      content = <span>2 points</span>;\n      break;\n\n    case NIGIRIS.squid:\n      content = <span>3 points</span>;\n      break;\n\n    case ROLLS.maki:\n      content = ctx.numPlayers <= 5\n        ? <span>Most: 6/3</span>\n        : <span>Most: 6/4/2</span>;\n      break;\n\n    case ROLLS.temaki:\n      content = ctx.numPlayers <= 2\n        ? <span>Most: 4</span>\n        : <span>Most: 4<br />Least: -4</span>;\n      break;\n\n    case ROLLS.uramaki:\n      content = <span>First to 10: 8/5/2</span>;\n      break;\n\n    case APPETIZERS.dumpling:\n      content = <span>1 3 6 10 15</span>;\n      break;\n\n    case APPETIZERS.edamame:\n      content = <span>1 per opponents with edamame</span>;\n      break;\n\n    case APPETIZERS.eel:\n      content = <span>1 = -3<br />2+ = +7</span>;\n      break;\n\n    case APPETIZERS.onigiri:\n      content = <span>Unique: 1 4 9 16</span>;\n      break;\n\n    case APPETIZERS.misoSoup:\n      content = <span>3 points<br />Discard if any others played this turn</span>;\n      break;\n\n    case APPETIZERS.sashimi:\n      content = <span>3 = 10</span>;\n      break;\n\n    case APPETIZERS.tempura:\n      content = <span>2 = 5</span>;\n      break;\n\n    case APPETIZERS.tofu:\n      content = <span>1 = 2<br />2 = 6<br />3+ = 0</span>;\n      break;\n\n    case SPECIALS.soySauce:\n      content = <span>Most colors: 4</span>;\n      break;\n\n    case SPECIALS.tea:\n      content = <span>1 per card in your biggest set</span>;\n      break;\n\n    case SPECIALS.wasabi:\n      content = <span>Next nigiri 3</span>;\n      break;\n\n    case DESSERTS.matchaIceCream:\n      content = <span>4 = 12</span>;\n      break;\n\n    case DESSERTS.pudding:\n      content = ctx.numPlayers <= 2\n        ? <span>Most: 6</span>\n        : <span>Most: 6<br />Least: -6</span>;\n      break;\n\n    case DESSERTS.fruit:\n      content = <span>Per type:<br />(-2) 0 1 3 6 10</span>;\n      break;\n\n    default:\n      console.error(`Unknown card: ${card.name}`);\n      return null;\n  }\n\n  return <aside>{content}</aside>;\n}\n\n/**\n * @param {object} props\n * @param {Ctx} props.ctx\n * @param {Card} props.card\n * @param {any=} props.onClick\n * @param {boolean=} props.disabled\n */\nfunction Card({ ctx, card, onClick, disabled }) {\n  const { name, category, count, variants } = card;\n\n  const [isHelpTextShown, setIsHelpTextShown] = useState(false);\n\n  const toggleShowHelpText = useCallback((event) => {\n    event.preventDefault();\n    setIsHelpTextShown(value => !value);\n  }, [setIsHelpTextShown]);\n\n  return (\n    <button\n      className={classNames({ clickable: onClick != null && !disabled })}\n      onContextMenu={toggleShowHelpText}\n      onClick={disabled ? null : onClick}\n      disabled={disabled}\n    >\n      <div className={classNames('card', category.toLowerCase(), { showHelpText: isHelpTextShown })}>\n        <div className=\"name\">\n          {name}\n          {count && <span>&nbsp;{count}</span>}\n          {variants && <span>:<br />{variants.map((variant, i) => <span key={i}>{variant}<br /></span>)}</span>}\n        </div>\n        <HelpText ctx={ctx} card={card} />\n      </div>\n    </button>\n  );\n}\n\nfunction Rules() {\n  return (\n    <Link\n      className=\"help\"\n      to=\"/rules\"\n      target=\"_blank\"\n    >\n      <span role=\"img\" aria-label=\"View rules\"></span>\n    </Link>\n  )\n}\n\n/**\n * @param {object} props\n * @param {G} props.G\n * @param {Ctx} props.ctx\n * @param {string} props.playerID\n * @param {any} props.moves\n * @param {Match['players']} props.matchData\n */\nexport default function Board({ G, ctx, playerID, moves, matchData }) {\n  const { hand, picked } = G.players[playerID];\n  const numRound = getNumRound(ctx);\n  const { gameover, turn } = ctx;\n  const allPlayerIDs = Object.keys(G.played);\n  const currentPlayerIndex = allPlayerIDs.indexOf(playerID);\n  const otherPlayerIDs = allPlayerIDs.slice(currentPlayerIndex + 1).concat(allPlayerIDs.slice(0, currentPlayerIndex));\n\n  const playerNameFor = id => matchData.find(player => `${player.id}` === id)?.name || `Player ${id}`;\n\n  const pickCard = (i) => (event) => {\n    event.preventDefault();\n\n    if (!picked) {\n      moves.pickCard(i);\n    }\n  };\n\n  if (gameover) {\n    const ScoreRow = ({ playerID, name=undefined }) => (\n      <tr>\n        <td>\n          {name || playerNameFor(playerID)}\n          {gameover.winner === playerID && <span role=\"img\" aria-label=\"Winner\"></span>}\n        </td>\n        {range(numRound).map(i =>\n          <td key={i}>{G.scores[playerID][i]}</td>\n        )}\n        <td>{sum(G.scores[playerID])}</td>\n      </tr>\n    );\n\n    return (\n      <div className=\"gameover\">\n        <table>\n          <thead>\n            <tr>\n              <th>Player</th>\n              {range(numRound).map(i =>\n                <th key={i}>Round {i + 1}</th>\n              )}\n              <th>Total</th>\n            </tr>\n          </thead>\n          <tbody>\n            <ScoreRow playerID={playerID} name=\"You\" />\n            {otherPlayerIDs.map(id =>\n              <ScoreRow key={id} playerID={id} />\n            )}\n          </tbody>\n        </table>\n        <Link to=\"/new\">Click to play another game</Link>\n      </div>\n    );\n  }\n\n  const PlayedCards = ({ playerID, picked=undefined, name=undefined }) => {\n    const cards = partition(G.played[playerID], card => card.round != null);\n    const score = sum(G.scores[playerID]);\n\n    return (\n      <figure>\n        <figcaption>\n          {name || playerNameFor(playerID)}\n          {score > 0 && <span>, score {score}</span>}\n        </figcaption>\n        <ol>\n          {cards.true.map((card, i) => (\n            <li key={`${i}-${card.round}`}>\n              <Card card={card} ctx={ctx} />\n            </li>\n          ))}\n          {cards.false.map((card, i) => (\n            <li key={i}>\n              <Card card={card} ctx={ctx} />\n            </li>\n          ))}\n          {picked && (\n            <li>\n              <Card card={picked} ctx={ctx} />\n            </li>\n          )}\n        </ol>\n      </figure>\n    );\n  };\n\n  return (\n    <Fragment>\n      {picked && <em className=\"status\">Waiting for other players&hellip;</em>}\n      <figure>\n        <figcaption>Round {numRound}, Hand {turn}</figcaption>\n        <ul>\n          {hand.map((card, i) => (\n            <li key={`${i}-${card.name}-${card.category}-${turn}`}>\n              <Card\n                card={card}\n                ctx={ctx}\n                onClick={pickCard(i)}\n                disabled={picked != null}\n              />\n            </li>\n          ))}\n        </ul>\n      </figure>\n      <PlayedCards playerID={playerID} picked={picked} name=\"You\" />\n      {otherPlayerIDs.map(id =>\n        <PlayedCards key={id} playerID={id} />\n      )}\n      <Rules />\n    </Fragment>\n  );\n}\n"],"sourceRoot":""}