{"version":3,"sources":["../node_modules/boardgame.io/dist/esm/core.js","shared/games/sgp.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray.js"],"names":["PlayerView","STRIP_SECRETS","G","ctx","playerID","r","undefined","secret","players","MIN_PLAYERS","MAX_PLAYERS","ONIGIRI_VARIANTS","FRUITS","FRUIT_VARIANTS","range","map","_","variant","flat","pairs","CATEGORIES","NIGIRIS","egg","salmon","squid","ROLLS","maki","temaki","uramaki","APPETIZERS","tempura","sashimi","misoSoup","tofu","eel","dumpling","onigiri","edamame","SPECIALS","wasabi","tea","soySauce","DESSERTS","matchaIceCream","pudding","fruit","scoreHand","hand","otherHands","numRound","score","sum","card","scoreCard","isFruitPlayed","some","otherHand","name","hasAnyFruit","scored","category","getSetInstances","cards","filter","getNumRolls","count","getNumCategories","distinct","round","length","numPlayers","setSize","setValue","scoreSet","numMakis","otherNumMakis","allNumMakis","sort","reverse","mostMakis","secondMostMakis","thirdMostMakis","numTemakis","otherNumTemakis","allNumTemakis","mostTemakis","leastTemakis","last","scores","allHands","numCards","uaramakis","numCard","numPlayer","push","shouldScore","numUramakis","find","item","item1","item2","nextScore","pop","player","leftovers","i","bestCounts","bestCount","turnPlayed","indexOf","numTofus","numEels","numDumplings","counts","Object","fromEntries","type","variants","uniques","entries","shape","numUniques","numOtherPlayersWithEdamame","Math","min","nextNigiri","slice","otherCard","max","values","numCategories","otherNumCategories","allNumCategories","numPuddings","otherNumPuddings","allNumPuddings","mostPuddings","leastPuddings","Error","setInstances","floor","getHandSize","getDeck","setupData","rolls","deck","desserts","appetizers","appetizer1","appetizer2","appetizer3","specials","special1","special2","random","Shuffle","dessert","concat","appetizer","numDesserts","getNumDesserts","getNumRound","gameover","handSize","turn","dealCards","played","getWinner","arr","arrayWithHoles","iterableToArray","unsupportedIterableToArray","nonIterableRest","first","playerScores","winner","bestScore","minPlayers","maxPlayers","setupDataSchema","required","properties","title","minimum","maximum","default","enum","validateSetupData","includes","setup","startingPlayer","getRandomInt","moves","pickCard","move","picked","isPickInvalid","INVALID_MOVE","removeAt","client","activePlayers","all","Stage","NULL","moveLimit","endIf","_ctx","every","onEnd","isRoundOver","id","events","endGame","key","value","newHands","Number","playerView","endStage","endTurn","endPhase","setStage","setPhase","setActivePlayers","disableUndo"],"mappings":"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","file":"static/js/8.78798b62.chunk.js","sourcesContent":["export { v as ActivePlayers, h as INVALID_MOVE, S as Stage, T as TurnOrder } from './turn-order-7578f7f3.js';\nimport 'immer';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * PlayerView reducers.\r\n */\r\nconst PlayerView = {\r\n    /**\r\n     * STRIP_SECRETS\r\n     *\r\n     * Reducer which removes a key named `secret` and\r\n     * removes all the keys in `players`, except for the one\r\n     * corresponding to the current playerID.\r\n     */\r\n    STRIP_SECRETS: (G, ctx, playerID) => {\r\n        let r = { ...G };\r\n        if (r.secret !== undefined) {\r\n            delete r.secret;\r\n        }\r\n        if (r.players) {\r\n            r.players = {\r\n                [playerID]: r.players[playerID],\r\n            };\r\n        }\r\n        return r;\r\n    },\r\n};\n\nexport { PlayerView };\n","import { PlayerView, INVALID_MOVE, Stage } from 'boardgame.io/core';\nimport { distinct, getRandomInt, last, pairs, range, removeAt, sum } from '../utils.js';\n\n/** @typedef {import('boardgame.io/dist/types/src/types').Ctx} Ctx **/\n/** @typedef {import('boardgame.io/dist/types/packages/core').INVALID_MOVE} INVALID_MOVE **/\n\n/**\n * @typedef {{\n *   name: string,\n *   category: string,\n *   scored?: boolean,\n *   count?: number,\n *   variants?: string[],\n *   round?: number,\n * }} Card\n *\n * @typedef {{\n *   secret: {\n *     deck: Card[],\n *     desserts: Card[],\n *   },\n *   players: {\n *     [player: string]: {\n *       hand: Card[],\n *       picked?: Card,\n *     },\n *   },\n *   played: {\n *     [player: string]: Card[],\n *   },\n * }} GameState\n *\n * @typedef {{\n *   scores: {\n *     [player: string]: number[],\n *   },\n *   startingPlayer: string,\n *   setupData: SetupData,\n * }} GameContext\n *\n * @typedef {GameState & GameContext} G\n *\n * @typedef {{\n *   rolls: string,\n *   appetizer1: string,\n *   appetizer2: string,\n *   appetizer3: string,\n *   special1: string,\n *   special2: string,\n *   dessert: string,\n * }} SetupData\n */\n\nconst MIN_PLAYERS = 2;\nconst MAX_PLAYERS = 8;\nconst NUM_ROUNDS = 3;\n\nconst ONIGIRI_VARIANTS = [\n  'square',\n  'circle',\n  'triangle',\n  'rectangle',\n];\n\nconst FRUITS = [\n  'watermelon',\n  'pineapple',\n  'orange',\n];\n\nconst FRUIT_VARIANTS = [\n  ...range(2).map(_ => FRUITS.map(variant => ([variant, variant]))).flat(),\n  ...range(3).map(_ => pairs(FRUITS)).flat(),\n];\n\nconst CATEGORIES = {\n  dessert: 'Dessert',\n  appetizer: 'Appetizer',\n  roll: 'Rolls',\n  nigiri: 'Nigiri',\n  special: 'Special',\n};\n\nexport const NIGIRIS = {\n  egg: 'Egg',\n  salmon: 'Salmon',\n  squid: 'Squid',\n};\n\nexport const ROLLS = {\n  maki: 'Maki',\n  temaki: 'Temaki',\n  uramaki: 'Uramaki',\n};\n\nexport const APPETIZERS = {\n  tempura: 'Tempura',\n  sashimi: 'Sashimi',\n  misoSoup: 'Miso Soup',\n  tofu: 'Tofu',\n  eel: 'Eel',\n  dumpling: 'Dumpling',\n  onigiri: 'Onigiri',\n  edamame: 'Edamame',\n};\n\nexport const SPECIALS = {\n  wasabi: 'Wasabi',\n  tea: 'Tea',\n  soySauce: 'Soy Sauce',\n};\n\nexport const DESSERTS = {\n  matchaIceCream: 'Matcha Ice Cream',\n  pudding: 'Pudding',\n  fruit: 'Fruit',\n};\n\n/**\n * @param {Card[]} hand\n * @param {Card[][]} otherHands\n * @param {number} numRound\n * @returns {number}\n */\nexport function scoreHand(hand, otherHands, numRound) {\n  let score = sum(hand.map(card => scoreCard(card, hand, otherHands, numRound)));\n\n  const isFruitPlayed = otherHands.some(otherHand => otherHand.some(card => card.name === DESSERTS.fruit));\n  const hasAnyFruit = hand.some(card => card.name === DESSERTS.fruit);\n\n  if (isFruitPlayed && !hasAnyFruit) {\n    score -= 6;\n  }\n\n  return score;\n}\n\n/**\n * @param {Card} card\n * @param {Card[]} hand\n * @param {Card[][]} otherHands\n * @param {number} numRound\n * @returns {number}\n */\nexport function scoreCard(card, hand, otherHands, numRound) {\n  if (card.scored) {\n    return 0;\n  }\n\n  if (card.category === CATEGORIES.dessert && numRound !== NUM_ROUNDS) {\n    return 0;\n  }\n\n  /**\n   * @param {Card[]} cards\n   * @returns {Card[]}\n   */\n  const getSetInstances = cards => cards.filter(({ name }) => name === card.name);\n\n  /**\n   * @param {Card[]} cards\n   * @returns {number}\n   */\n  const getNumRolls = cards => sum(getSetInstances(cards).map(({ count }) => count));\n\n  /**\n   * @param {Card[]} cards\n   * @returns {number}\n   */\n  const getNumCategories = cards => distinct(...cards.filter(card => card.round == null).map(({ category }) => category)).length;\n\n  const numPlayers = otherHands.length + 1;\n\n  let setSize = undefined;\n  let setValue = undefined;\n  let scoreSet = false;\n\n  let score = 0;\n\n  switch (card.name) {\n    case NIGIRIS.egg:\n      score = 1;\n      break;\n\n    case NIGIRIS.salmon:\n      score = 2;\n      break;\n\n    case NIGIRIS.squid:\n      score = 3;\n      break;\n\n    case ROLLS.maki:\n      {\n        const numMakis = getNumRolls(hand);\n        const otherNumMakis = otherHands.map(otherHand => getNumRolls(otherHand));\n        const allNumMakis = distinct(numMakis, ...otherNumMakis).sort().reverse();\n        const mostMakis = allNumMakis[0];\n        const secondMostMakis = allNumMakis[1];\n\n        if (numPlayers <= 5) {\n          if (numMakis === mostMakis) {\n            score = 6;\n          } else if (numMakis === secondMostMakis) {\n            score = 3;\n          } else {\n            score = 0;\n          }\n        } else {\n          const thirdMostMakis = allNumMakis[2];\n\n          if (numMakis === mostMakis) {\n            score = 6;\n          } else if (numMakis === secondMostMakis) {\n            score = 4;\n          } else if (numMakis === thirdMostMakis) {\n            score = 2;\n          } else {\n            score = 0;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case ROLLS.temaki:\n      {\n        const numTemakis = getNumRolls(hand);\n        const otherNumTemakis = otherHands.map(otherHand => getNumRolls(otherHand));\n        const allNumTemakis = distinct(numTemakis, ...otherNumTemakis).sort().reverse();\n        const mostTemakis = allNumTemakis[0];\n        const leastTemakis = last(allNumTemakis);\n\n        if (numTemakis === mostTemakis) {\n          score = 4;\n        }\n\n        if (numPlayers > 2) {\n          if (numTemakis === leastTemakis) {\n            score = -4;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case ROLLS.uramaki:\n      {\n        const scores = [2, 5, 8];\n\n        const allHands = [hand, ...otherHands].map(cards => cards.filter(card => card.round == null));\n        const numCards = allHands[0].length;\n        const uaramakis = range(numPlayers).map(_ => ([]));\n\n        for (let numCard = 0; numCard < numCards; numCard++) {\n          for (let numPlayer = 0; numPlayer < numPlayers; numPlayer++) {\n            const card = allHands[numPlayer][numCard];\n\n            if (card.name === ROLLS.uramaki) {\n              uaramakis[numPlayer].push(card.count);\n            }\n          }\n\n          const shouldScore = [];\n\n          for (let numPlayer = 0; numPlayer < numPlayers; numPlayer++) {\n            const numUramakis = sum(uaramakis[numPlayer]);\n\n            if (numUramakis >= 10) {\n              const scored = shouldScore.find(item => item.numUramakis === numUramakis);\n\n              if (scored == null) {\n                shouldScore.push({ numUramakis, players: [numPlayer] });\n              } else {\n                scored.players.push(numPlayer);\n              }\n            }\n          }\n\n          shouldScore.sort((item1, item2) => item2.numUramakis - item1.numUramakis);\n\n          for (const { players } of shouldScore) {\n            const nextScore = scores.pop() || 0;\n\n            for (const player of players) {\n              if (player === 0) {\n                score += nextScore;\n              }\n\n              uaramakis[player] = [];\n            }\n\n            if (players.length > 1) {\n              scores.pop();\n            }\n          }\n        }\n\n        const leftovers = uaramakis.map((cards, i) => ({ player: i, count: sum(cards) }));\n        const bestCounts = distinct(...leftovers.map(({ count }) => count)).sort();\n\n        while (scores.length > 0 && bestCounts.length > 0) {\n          const nextScore = scores.pop();\n          const bestCount = bestCounts.pop();\n\n          for (const { player, count } of leftovers) {\n            if (count === bestCount && player === 0) {\n              score += nextScore;\n            }\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.tempura:\n      setSize = 2;\n      setValue = 5;\n      break;\n\n    case APPETIZERS.sashimi:\n      setSize = 3;\n      setValue = 10;\n      break;\n\n    case APPETIZERS.misoSoup:\n      {\n        const turnPlayed = hand.filter(card => card.round == null).indexOf(card);\n        const hasOtherMisoSoup = otherHands.some(otherHand => otherHand.filter(card => card.round == null)[turnPlayed].name === APPETIZERS.misoSoup);\n        score = hasOtherMisoSoup ? 0 : 3;\n      }\n      break;\n\n    case APPETIZERS.tofu:\n      {\n        const numTofus = getSetInstances(hand).length;\n\n        if (numTofus === 1) {\n          score = 2;\n        } else if (numTofus === 2) {\n          score = 6;\n        } else if (numTofus >= 3) {\n          score = 0;\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.eel:\n      {\n        const numEels = getSetInstances(hand).length;\n\n        if (numEels === 1) {\n          score = -3;\n        } else if (numEels >= 2) {\n          score = 7;\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.dumpling:\n      {\n        const numDumplings = getSetInstances(hand).length;\n\n        if (numDumplings === 1) {\n          score = 1;\n        } else if (numDumplings === 2) {\n          score = 3;\n        } else if (numDumplings === 3) {\n          score = 6;\n        } else if (numDumplings === 4) {\n          score = 10;\n        } else if (numDumplings >= 5) {\n          score = 15;\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.onigiri:\n      {\n        const counts = Object.fromEntries(ONIGIRI_VARIANTS.map(type => [type, 0]));\n\n        for (const card of getSetInstances(hand)) {\n          counts[card.variants[0]]++;\n        }\n\n        while (true) {\n          const uniques = Object.entries(counts).filter(([_, count]) => count > 0).map(([shape, _]) => shape);\n          const numUniques = uniques.length;\n\n          if (numUniques === 0) {\n            break;\n          } else if (numUniques === 4) {\n            score += 16;\n          } else if (numUniques === 3) {\n            score += 9\n          } else if (numUniques === 2) {\n            score += 4;\n          } else if (numUniques === 1) {\n            score += 1;\n          }\n\n          for (const shape of uniques) {\n            counts[shape]--;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case APPETIZERS.edamame:\n      {\n        const numOtherPlayersWithEdamame = otherHands.filter(otherHand => getSetInstances(otherHand).length > 0).length;\n\n        score = Math.min(4, numOtherPlayersWithEdamame);\n      }\n      break;\n\n    case SPECIALS.wasabi:\n      {\n        const turnPlayed = hand.indexOf(card);\n        const nextNigiri = hand.slice(turnPlayed).filter(otherCard => !otherCard.scored && otherCard.category === CATEGORIES.nigiri)[0];\n\n        if (nextNigiri == null) {\n          score = 0;\n        } else {\n          score = scoreCard(nextNigiri, hand, otherHands, numRound) * 3;\n        }\n      }\n      break;\n\n    case SPECIALS.tea:\n      {\n        const counts = {};\n\n        for (const card of hand) {\n          counts[card.category] = (counts[card.category] || 0) + 1;\n        }\n\n        score = Math.max(...Object.values(counts));\n      }\n      break;\n\n    case SPECIALS.soySauce:\n      {\n        const numCategories = getNumCategories(hand);\n        const otherNumCategories = otherHands.map(otherHand => getNumCategories(otherHand));\n        const allNumCategories = distinct(numCategories, ...otherNumCategories).sort().reverse();\n        const mostCategories = allNumCategories[0];\n\n        if (numCategories === mostCategories) {\n          score = 4;\n        }\n      }\n      break;\n\n    case DESSERTS.matchaIceCream:\n      setSize = 4;\n      setValue = 12;\n      break;\n\n    case DESSERTS.pudding:\n      {\n        const numPuddings = getSetInstances(hand).length;\n        const otherNumPuddings = otherHands.map(otherHand => getSetInstances(otherHand).length);\n        const allNumPuddings = distinct(numPuddings, ...otherNumPuddings).sort().reverse();\n        const mostPuddings = allNumPuddings[0];\n        const leastPuddings = last(allNumPuddings);\n\n        if (numPuddings === mostPuddings) {\n          score = 6;\n        }\n\n        if (numPlayers > 2) {\n          if (numPuddings === leastPuddings) {\n            score = -6;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    case DESSERTS.fruit:\n      {\n        const counts = Object.fromEntries(FRUITS.map(variant => [variant, 0]));\n\n        for (const card of getSetInstances(hand)) {\n          for (const variant of card.variants) {\n            counts[variant]++;\n          }\n        }\n\n        for (const count of Object.values(counts)) {\n          if (count === 0) {\n            score -= 2;\n          } else if (count === 1) {\n            score += 0;\n          } else if (count === 2) {\n            score += 1;\n          } else if (count === 3) {\n            score += 3;\n          } else if (count === 4) {\n            score += 6;\n          } else if (count >= 5) {\n            score += 10;\n          }\n        }\n\n        scoreSet = true;\n      }\n      break;\n\n    default:\n      throw new Error(`Unknown card: ${card.name}`);\n  }\n\n  if (setValue != null && setSize != null) {\n    const setInstances = getSetInstances(hand);\n    score = Math.floor(setInstances.length / setSize) * setValue;\n    scoreSet = true;\n  }\n\n  if (scoreSet) {\n    const setInstances = getSetInstances(hand);\n\n    for (const otherCard of setInstances) {\n      otherCard.scored = true;\n    }\n  } else {\n    card.scored = true;\n  }\n\n  return score;\n}\n\n/**\n * @param {number} numPlayers\n * @returns {number}\n */\nfunction getHandSize(numPlayers) {\n  switch (numPlayers) {\n    case 2:\n    case 3:\n      return 10;\n\n    case 4:\n    case 5:\n      return 9;\n\n    case 6:\n    case 7:\n      return 8;\n\n    case 8:\n      return 7;\n\n    default:\n      throw new Error(`Unknown player count: ${numPlayers}`);\n  }\n}\n\n/**\n * @param {number} numPlayers\n * @param {number} numRound\n * @returns {number}\n */\nfunction getNumDesserts(numPlayers, numRound) {\n  switch (numPlayers) {\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      switch (numRound) {\n        case 1:\n          return 5;\n\n        case 2:\n          return 3;\n\n        case 3:\n          return 2;\n\n        default:\n          throw new Error(`Unknown round number: ${numRound}`);\n      }\n\n    case 6:\n    case 7:\n    case 8:\n      switch (numRound) {\n        case 1:\n          return 7;\n\n        case 2:\n          return 5;\n\n        case 3:\n          return 3;\n\n        default:\n          throw new Error(`Unknown round number: ${numRound}`);\n      }\n\n    default:\n      throw new Error(`Unknown player count: ${numPlayers}`);\n  }\n}\n\n/**\n * @param {G?} G\n * @param {Ctx} ctx\n * @param {SetupData} setupData\n * @returns {{ deck: Card[], desserts: Card[]}}\n */\nfunction getDeck(G, ctx, setupData) {\n  setupData = G?.setupData || setupData;\n\n  let rolls = [];\n\n  switch (setupData.rolls) {\n    case ROLLS.maki:\n      rolls = [\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.maki, count: 1 })),\n        ...range(5).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.maki, count: 2 })),\n        ...range(3).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.maki, count: 3 })),\n      ];\n      break;\n\n    case ROLLS.temaki:\n      rolls = range(12).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.temaki, count: 1 }));\n      break;\n\n    case ROLLS.uramaki:\n      rolls = [\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.uramaki, count: 3 })),\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.uramaki, count: 4 })),\n        ...range(4).map(_ => ({ category: CATEGORIES.roll, name: ROLLS.uramaki, count: 5 })),\n      ];\n      break;\n\n    default:\n      throw new Error(`Unknown rolls: ${setupData.rolls}`);\n  }\n\n  const appetizers = [setupData.appetizer1, setupData.appetizer2, setupData.appetizer3];\n  const specials = [setupData.special1, setupData.special2];\n\n  let deck;\n\n  if (G?.secret?.deck) {\n    deck = G.secret.deck.filter(card => card.category === CATEGORIES.dessert);\n  } else {\n    deck = [];\n  }\n\n  let desserts;\n\n  if (G?.secret?.desserts) {\n    desserts = [...G.secret.desserts];\n  } else {\n    desserts = ctx.random.Shuffle(\n      range(15).map(i => {\n        const dessert = {\n          category: CATEGORIES.dessert,\n          name: setupData.dessert,\n        };\n\n        if (dessert.name === DESSERTS.fruit) {\n          dessert.variants = FRUIT_VARIANTS[i];\n        }\n\n        return dessert;\n      })\n    );\n  }\n\n  deck = deck.concat([\n    ...range(4).map(_ => ({ category: CATEGORIES.nigiri, name: NIGIRIS.egg })),\n    ...range(5).map(_ => ({ category: CATEGORIES.nigiri, name: NIGIRIS.salmon })),\n    ...range(3).map(_ => ({ category: CATEGORIES.nigiri, name: NIGIRIS.squid })),\n    ...rolls,\n    ...appetizers.map(name => range(8).map(i => {\n        const appetizer = {\n          category: CATEGORIES.appetizer,\n          name,\n        };\n\n        if (appetizer.name === APPETIZERS.onigiri) {\n          appetizer.variants = [ONIGIRI_VARIANTS[i % ONIGIRI_VARIANTS.length]];\n        }\n\n        return appetizer;\n      })).flat(),\n    ...specials.map(name => range(3).map(_ => ({ category: CATEGORIES.special, name }))).flat(),\n  ]);\n\n  const numDesserts = getNumDesserts(ctx.numPlayers, getNumRound(ctx));\n\n  for (let i = 0; i < numDesserts; i++) {\n    deck.push(desserts.pop());\n  }\n\n  return {\n    deck: ctx.random.Shuffle(deck),\n    desserts,\n  };\n}\n\n/**\n * @param {Ctx} ctx\n * @returns {number}\n */\nexport function getNumRound(ctx) {\n  if (ctx.gameover) {\n    return NUM_ROUNDS;\n  }\n\n  const handSize = getHandSize(ctx.numPlayers);\n  const turn = ctx.turn === 0 ? ctx.turn : ctx.turn - 1;\n  return Math.floor(turn / handSize) + 1;\n}\n\n/**\n * @param {G?} G\n * @param {Ctx} ctx\n * @param {SetupData?} setupData\n * @returns {GameState}\n */\nfunction dealCards(G, ctx, setupData=null) {\n  const { deck, desserts } = getDeck(G, ctx, setupData);\n\n  const numRound = getNumRound(ctx);\n\n  const players = Object.fromEntries(range(ctx.numPlayers).map(i => ([\n    i,\n    {\n      hand: range(getHandSize(ctx.numPlayers)).map(_ => {\n        const card = deck.pop();\n\n        if (card == null) {\n          throw new Error(`Not enough cards in deck for player ${i}`);\n        }\n\n        return card;\n      }),\n    },\n  ])));\n\n  const played = G?.played\n    ? Object.fromEntries(Object.entries(G.played).map(([playerID, played]) => [\n        playerID,\n        played.filter(card => card.category === CATEGORIES.dessert).map(card => ({\n          ...card,\n          round: numRound - 1,\n        })),\n      ]))\n    : Object.fromEntries(range(ctx.numPlayers).map(playerID => ([\n        playerID,\n        [],\n      ])));\n\n  return {\n    secret: {\n      deck,\n      desserts,\n    },\n    players,\n    played,\n  };\n}\n\n/**\n * @param {G} G\n * @param {Ctx} _ctx\n * @returns {boolean}\n */\nfunction isRoundOver(G, _ctx) {\n  return Object.values(G.players).every(player => player.hand.length === 0);\n}\n\n/**\n * @param {G} G\n * @param {Ctx} _ctx\n * @returns {boolean}\n */\nfunction isTurnOver(G, _ctx) {\n  return Object.values(G.players).every(player => player.picked != null);\n}\n\n/**\n * @param {G} G\n * @returns {{ winner: string }}\n */\nfunction getWinner(G) {\n  const [first, ...playerScores] = Object.entries(G.scores).map(([playerID, scores]) => ({ playerID, score: sum(scores) }));\n  let winner = first.playerID;\n  let bestScore = first.score;\n\n  const numDesserts = Object.fromEntries(Object.entries(G.played).map(([playerID, played]) => [\n    playerID,\n    played.filter(card => card.category === CATEGORIES.dessert).length,\n  ]));\n\n  for (const { playerID, score } of playerScores) {\n    if (score > bestScore || (score === bestScore && numDesserts[playerID] > numDesserts[winner])) {\n      bestScore = score;\n      winner = playerID;\n    }\n  }\n\n  return { winner };\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n */\nfunction onTurnEnd(G, ctx) {\n  for (const [playerID, player] of Object.entries(G.players)) {\n    G.played[playerID].push(player.picked);\n    G.players[playerID].picked = undefined;\n  }\n\n  if (isRoundOver(G, ctx)) {\n    const numRound = getNumRound(ctx);\n\n    for (const [playerID, played] of Object.entries(G.played)) {\n      const otherHands = Object.entries(G.played).filter(([id, _]) => id !== playerID).map(([_, hand]) => hand);\n\n      const score = scoreHand(played, otherHands, numRound);\n\n      G.scores[playerID].push(score);\n    }\n\n    if (numRound === NUM_ROUNDS) {\n      const winner = getWinner(G);\n      ctx.events.endGame(winner);\n    } else {\n      for (const [key, value] of Object.entries(dealCards(G, ctx))) {\n        G[key] = value;\n      }\n    }\n  } else {\n    const newHands = {};\n\n    for (const [playerID, player] of Object.entries(G.players)) {\n      newHands[(Number(playerID) + 1) % ctx.numPlayers] = player.hand;\n    }\n\n    for (const [playerID, hand] of Object.entries(newHands)) {\n      G.players[playerID] = { hand };\n    }\n  }\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {number?} i\n * @returns {string?}\n */\nfunction isPickInvalid(G, ctx, i) {\n  const player = G.players[ctx.playerID];\n\n  if (i == null) {\n    return 'played_no_card';\n  }\n\n  if (i >= player.hand.length) {\n    return 'played_unknown_card';\n  }\n\n  if (player.picked != null) {\n    return 'played_card_already';\n  }\n}\n\n/**\n * @param {G} G\n * @param {Ctx} ctx\n * @param {number} i\n * @returns {INVALID_MOVE?}\n */\nfunction pickCard(G, ctx, i) {\n  if (isPickInvalid(G, ctx, i)) {\n    return INVALID_MOVE;\n  }\n\n  const player = G.players[ctx.playerID];\n\n  player.picked = player.hand[i];\n  player.hand = removeAt(player.hand, i);\n}\n\nexport default {\n  name: 'sashimi-express',\n\n  minPlayers: MIN_PLAYERS,\n  maxPlayers: MAX_PLAYERS,\n\n  setupDataSchema: {\n    required: [\n      'numPlayers',\n      'rolls',\n      'appetizer1',\n      'appetizer2',\n      'appetizer3',\n      'special1',\n      'special2',\n      'dessert',\n    ],\n    properties: Object.fromEntries([\n      [\n        'numPlayers',\n        {\n          title: 'Number of players',\n          type: 'integer',\n          minimum: MIN_PLAYERS,\n          maximum: MAX_PLAYERS,\n          default: MIN_PLAYERS,\n        },\n      ],\n      [\n        'rolls',\n        {\n          title: 'Rolls',\n          type: 'string',\n          enum: Object.values(ROLLS),\n          default: Object.values(ROLLS)[0],\n        },\n      ],\n      ...range(3).map(i => ([\n        `appetizer${i + 1}`,\n        {\n          title: `Appetizer ${i + 1}`,\n          type: 'string',\n          enum: Object.values(APPETIZERS),\n          default: Object.values(APPETIZERS)[i],\n        },\n      ])),\n      ...range(2).map(i => ([\n        `special${i + 1}`,\n        {\n          title: `Special ${i + 1}`,\n          type: 'string',\n          enum: Object.values(SPECIALS),\n          default: Object.values(SPECIALS)[i],\n        },\n      ])),\n      [\n        'dessert',\n        {\n          title: 'Dessert',\n          type: 'string',\n          enum: Object.values(DESSERTS),\n          default: Object.values(DESSERTS)[0],\n        },\n      ],\n    ]),\n  },\n\n  /**\n   * @param {SetupData} setupData\n   * @param {number} numPlayers\n   * @returns {string?}\n   */\n  validateSetupData: (setupData, numPlayers) => {\n    const appetizers = [setupData.appetizer1, setupData.appetizer2, setupData.appetizer3];\n    const specials = [setupData.special1, setupData.special2];\n\n    if (distinct(...appetizers).length !== appetizers.length) {\n      return 'All appetizers must be different';\n    }\n\n    if (distinct(...specials).length !== specials.length) {\n      return 'All specials must be different';\n    }\n\n    if (numPlayers === 2 && appetizers.includes(APPETIZERS.edamame)) {\n      return `${APPETIZERS.edamame} can't be used in a two player game`;\n    }\n  },\n\n  /**\n   * @param {Ctx} ctx\n   * @param {SetupData} setupData\n   * @returns {G}\n   */\n  setup: (ctx, setupData) => ({\n    ...dealCards(null, ctx, setupData),\n    scores: Object.fromEntries(range(ctx.numPlayers).map(i => [`${i}`, []])),\n    startingPlayer: `${getRandomInt(ctx.numPlayers + 1)}`,\n    setupData,\n  }),\n\n  moves: {\n    pickCard: {\n      move: pickCard,\n      client: false,\n    },\n  },\n\n  turn: {\n    activePlayers: {\n      all: Stage.NULL,\n      moveLimit: 1,\n    },\n    endIf: isTurnOver,\n    onEnd: onTurnEnd,\n  },\n\n  playerView: PlayerView.STRIP_SECRETS,\n\n  events: {\n    endStage: false,\n    endTurn: false,\n    endPhase: false,\n    endGame: false,\n    setStage: false,\n    setPhase: false,\n    setActivePlayers: false,\n  },\n\n  disableUndo: true,\n};\n","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}"],"sourceRoot":""}